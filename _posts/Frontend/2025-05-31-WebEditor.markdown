---
layout: post
title: "[FE] 웹 에디더 개발자"
date: 2025-05-31
category: [Frontend]
---

# 프론트엔드 웹 에디터 개발자

🌱 면접 준비 블로그.. 시작..! <br>
미리디 프론트엔드 웹 에디터 개발팀에 현장실습을 지원했다. 그 전에 웹 에디터가 뭔지 알아야겠지?<br>

- 미리캔버스 웹 에디터 개발 담당
- 웹 에디터 캔버스 개발자는 미리캔버스의 핵심 기능인 디자인 편집기를 개발하며, React, Typescript 등 최신 웹 기술을 활용해 사용성 높은 인터페이스와 성능 최적화를 구현
- 다양한 사용자 시나리오를 고려한 캔버스 렌더링, 도구 개발, 실시간 협업 기능 등을 설계하며, UX 개선과 기술적 혁신을 주도
- javascript, oop 개발을 통한 프로그래밍 지식 전반에 대한 이해도 상승

## 웹 에디터 엔진 개발자?

[미리디 인터뷰 참고](https://www.miridih.com/ko/devinterview2) <br>
➡️ 웹 에디터 엔진 개발자는 사용자들이 미리캔버스에서 편집 활동을 원활하게 할 수 있도록 핵심 기능과 내부 로직을 만드는 역할을 한다. <br>
➡️ 이에 더해 성능 최적화, 동시 편집 기능 지원과 같은 중요한 기술적 문제를 해결하기 <br>
⭐ 부드럽고 정확한 편집 경험을 만들기 위한 핵심 로직을 설계하고 구현하는 소프트웨어 엔지니어

### 일반적인 프론트엔드 개발과의 차이점

프론트엔드 개발이 사용자 인터페이스 구축이나 서버와의 소통 등에 집중하는 태스크를 가지고 있다면, 엔진 개발은 그 뒤편에서 **사용자 액션이 정확하게 동작하도록 에디터 내 로직과 구조를 설계하는 데 중점**을 둔다.

## 미리캔버스의 아키텍처

- 편집 영역과 템플릿, 요소 패널이 각각 독립된 서비스로 구성되어 있는 MFA(Micro Frontend Architecture) 구조
  - 각 기능들이 command 패턴을 통해 서로 소통하고, OOP 설계와 함수형 프로그래밍이 적절히 혼합된 복잡한 구조
- 모듈들이 역할에 따라 분류되어 있는 구조
- 단일 페이지 안에서 수많은 상태와 액션들이 서로 영향을 주며 동작

> #### 💡**MFA(Micro Frontend Architecture)**
>
> 프론트엔드 애플리케이션을 작은 단위로 분리해서 개발, 배포, 유지보수하는 구조 <br>
> 대규모 프론트엔드 코드 베이스를 여러 팀이 동시에 작업할 때, 서로 충돌 없이 독립적으로 개발 및 릴리즈할 수 있도록 도와줌. <br> 코드의 복잡도를 낮추고, 기술 스택을 팀별로 유연하게 선택할 수 있음<br>
> MFA의 3가지 구성요소: 🏠Host Shell(Container), 🧩Micro Apps(Micro Frontends), 🔗Integration Layer(통합 방식)
>
> - Host Shell: 전체 애플리케이션의 구조를 제공하는 최상위 shell로, 어떤 마이크로 앱을 언제 load할지 결정하는 역할
> - Micro Apps: 독립된 배포 단위로써, 특정 도메인 혹은 기능을 담당
> - Integration Layer: 여러 Micro App을 호스트하는 방식

> #### ✅ Command 패턴이란
>
> Command 패턴은 행동(명령, 요청)을 객체로 캡슐화해서, 서로 다른 요청, 큐잉(대기열)에 넣기, 실행 취소(undo) 등 기능을 유연하게 처리할 수 있게 해주는 디자인 패턴
> 어떤 작업(메시지 전송, 메소드 호출 등)을 Command 객체로 만들어서, 실행(or 취소) 로직을 보내는 쪽(Invoker)과 실제 동작을 수행하는 쪽(receiver)을 분리
>
> 💌 Command 패턴을 사용하면 좋은 경우
>
> - 사용자 인터페이스에서 버튼 클릭, 메뉴 선택 같은 작업을 캡쳐해서 나중에 처리해야 할 때
>   - 이전 동작 취소 / 다시 실행 기능
>   - "인쇄" 메뉴 클릭 시, 인쇄 요청을 Queue에 넣었다가 프린터가 준비되면 실행됨
> - 다양한 요청을 일관된 방법으로 실행, 취소, 재실행해야 할 때
>
> **💗장점**:
>
> - 호출자(invoker)와 실제 작업 수행자(receiver)를 완전히 분리
> - 요청을 객체로 캡슐화 → 큐에 넣었다가 나중에 실행 가능
> - 실행 취소 및 재실행 지원
>   **😓단점**:
> - 클래스 수 증가
> - 코드 구조가 다소 복잡해 보일 수 있음

> #### 🦁 객체 지향 프로그래밍 OOP
>
> 객체 지향 프로그래밍은 프로그램을 "객체(Object)"라는 독립적인 단위로 나누어 개발하는 패러다임으로, **객체는 데이터(속성, property)와 그 데이터를 처리하는 코드(method)를 함께 가지는 실체**
> 특징:
>
> - **캡슐화 Encapsulation**
>   - 데이터와 이를 처리하는 메소드를 하나의 클래스 내부에 묶어 두는 것
>   - 외부에서는 클래스 내부의 데이터에 직접 접근하지 못하도록 하고 method를 통해서만 조작하도록 제한하는 기법
> - **추상화 Abstraction**
> - **상속 Inheritance**
>   - 기존 클래스(부모 클래스)의 속성과 메소드(공통 기능)를 물려받아, 새로운 클래스(자식 클래스)를 정의하는 기법
> - **다형성 Polymorphism**
>   - 같은 이름의 메소드가 여러 형태로 동작할 수 있게 해주는 특징

> #### 🐾 모듈 Module
>
> 코드를 기능별로 나눠서 하나의 독립된 단위(파일 or 패키지)로 만든 것
> 모듈을 사용하는 이유:
>
> - 코드 가독성 향상
> - 재사용성 증가
> - 유지보수 용이
> - 협업 편리
