---
layout: post
title: "[FE] 웹 에디터 개발자"
date: 2025-05-31
category: [Frontend]
---

# 프론트엔드 웹 에디터 개발자

🌱 면접 준비 블로그.. 시작..! <br>
미리디 프론트엔드 웹 에디터 개발팀에 현장실습을 지원했다. 그 전에 웹 에디터가 뭔지 알아야겠지?<br>

- 미리캔버스 웹 에디터 개발 담당
- 웹 에디터 캔버스 개발자는 미리캔버스의 핵심 기능인 디자인 편집기를 개발하며, React, Typescript 등 최신 웹 기술을 활용해 사용성 높은 인터페이스와 성능 최적화를 구현
- 다양한 사용자 시나리오를 고려한 캔버스 렌더링, 도구 개발, 실시간 협업 기능 등을 설계하며, UX 개선과 기술적 혁신을 주도
- javascript, oop 개발을 통한 프로그래밍 지식 전반에 대한 이해도 상승

## 웹 에디터 엔진 개발자?

[미리디 인터뷰 참고](https://www.miridih.com/ko/devinterview2) <br>
➡️ 웹 에디터 엔진 개발자는 사용자들이 미리캔버스에서 편집 활동을 원활하게 할 수 있도록 핵심 기능과 내부 로직을 만드는 역할을 한다. <br>
➡️ 이에 더해 성능 최적화, 동시 편집 기능 지원과 같은 중요한 기술적 문제를 해결하기 <br>
⭐ 부드럽고 정확한 편집 경험을 만들기 위한 핵심 로직을 설계하고 구현하는 소프트웨어 엔지니어

### 일반적인 프론트엔드 개발과의 차이점

프론트엔드 개발이 사용자 인터페이스 구축이나 서버와의 소통 등에 집중하는 태스크를 가지고 있다면, 엔진 개발은 그 뒤편에서 **사용자 액션이 정확하게 동작하도록 에디터 내 로직과 구조를 설계하는 데 중점**을 둔다.

## 미리캔버스의 아키텍처

- 편집 영역과 템플릿, 요소 패널이 각각 독립된 서비스로 구성되어 있는 MFA(Micro Frontend Architecture) 구조
  - 각 기능들이 command 패턴을 통해 서로 소통하고, OOP 설계와 함수형 프로그래밍이 적절히 혼합된 복잡한 구조
- 모듈들이 역할에 따라 분류되어 있는 구조
- 단일 페이지 안에서 수많은 상태와 액션들이 서로 영향을 주며 동작

> #### 💡**MFA(Micro Frontend Architecture)**
>
> 프론트엔드 애플리케이션을 작은 단위로 분리해서 개발, 배포, 유지보수하는 구조 <br>
> 대규모 프론트엔드 코드 베이스를 여러 팀이 동시에 작업할 때, 서로 충돌 없이 독립적으로 개발 및 릴리즈할 수 있도록 도와줌. <br> 코드의 복잡도를 낮추고, 기술 스택을 팀별로 유연하게 선택할 수 있음<br>
> MFA의 3가지 구성요소: 🏠Host Shell(Container), 🧩Micro Apps(Micro Frontends), 🔗Integration Layer(통합 방식)
>
> - Host Shell: 전체 애플리케이션의 구조를 제공하는 최상위 shell로, 어떤 마이크로 앱을 언제 load할지 결정하는 역할
> - Micro Apps: 독립된 배포 단위로써, 특정 도메인 혹은 기능을 담당
> - Integration Layer: 여러 Micro App을 호스트하는 방식

> #### ✅ Command 패턴이란
>
> Command 패턴은 행동(명령, 요청)을 객체로 캡슐화해서, 서로 다른 요청, 큐잉(대기열)에 넣기, 실행 취소(undo) 등 기능을 유연하게 처리할 수 있게 해주는 디자인 패턴
> 어떤 작업(메시지 전송, 메소드 호출 등)을 Command 객체로 만들어서, 실행(or 취소) 로직을 보내는 쪽(Invoker)과 실제 동작을 수행하는 쪽(receiver)을 분리
>
> 💌 Command 패턴을 사용하면 좋은 경우
>
> - 사용자 인터페이스에서 버튼 클릭, 메뉴 선택 같은 작업을 캡쳐해서 나중에 처리해야 할 때
>   - 이전 동작 취소 / 다시 실행 기능
>   - "인쇄" 메뉴 클릭 시, 인쇄 요청을 Queue에 넣었다가 프린터가 준비되면 실행됨
> - 다양한 요청을 일관된 방법으로 실행, 취소, 재실행해야 할 때
>
> **💗장점**:
>
> - 호출자(invoker)와 실제 작업 수행자(receiver)를 완전히 분리
> - 요청을 객체로 캡슐화 → 큐에 넣었다가 나중에 실행 가능
> - 실행 취소 및 재실행 지원
>   **😓단점**:
> - 클래스 수 증가
> - 코드 구조가 다소 복잡해 보일 수 있음

> #### 🦁 객체 지향 프로그래밍 OOP
>
> 객체 지향 프로그래밍은 프로그램을 "객체(Object)"라는 독립적인 단위로 나누어 개발하는 패러다임으로, **객체는 데이터(속성, property)와 그 데이터를 처리하는 코드(method)를 함께 가지는 실체**
> 특징:
>
> - **캡슐화 Encapsulation**
>   - 데이터와 이를 처리하는 메소드를 하나의 클래스 내부에 묶어 두는 것
>   - 외부에서는 클래스 내부의 데이터에 직접 접근하지 못하도록 하고 method를 통해서만 조작하도록 제한하는 기법
> - **추상화 Abstraction**
> - **상속 Inheritance**
>   - 기존 클래스(부모 클래스)의 속성과 메소드(공통 기능)를 물려받아, 새로운 클래스(자식 클래스)를 정의하는 기법
> - **다형성 Polymorphism**
>   - 같은 이름의 메소드가 여러 형태로 동작할 수 있게 해주는 특징

> #### 🐾 모듈 Module
>
> 코드를 기능별로 나눠서 하나의 독립된 단위(파일 or 패키지)로 만든 것
> 모듈을 사용하는 이유:
>
> - 코드 가독성 향상
> - 재사용성 증가
> - 유지보수 용이
> - 협업 편리

### JavaScript와 TypeScript의 차이점

```js
function sum(a, b) {
  return a + b;
}

console.log(sum(2, 3)); // 5
console.log(sum(2, "3")); // "23" (의도치 않게 문자열 결합)
```

```ts
function sum(a: number, b: number): number {
  return a + b;
}

console.log(sum(2, 3)); // 5
console.log(sum(2, "3")); // 컴파일 오류! Argument of type 'string' is not assignable to parameter of type 'number'.
```

| 항목                 | JavaScript                                       | TypeScript                                                         |
| -------------------- | ------------------------------------------------ | ------------------------------------------------------------------ |
| 언어 유형            | 동적 타이핑(Dynamic Typing) 스크립트 언어        | 정적 타이핑(Static Typing) 상위 집합(Superset)                     |
| 타입 시스템          | 런타임에 타입이 결정되며 타입 검사 없음          | 컴파일 시점에 타입 검사, 타입 어노테이션 및 타입 추론 지원         |
| 실행/컴파일 방식     | 인터프리터 방식, 별도 컴파일 과정 없이 즉시 실행 | 컴파일(tsc)을 통해 JavaScript로 변환 후 실행                       |
| 타입 선언            | ❌ (선택적 JSDoc 주석 사용 가능)                 | ✅ 변수, 함수, 클래스 등에 명시적 타입 선언 필수/권장              |
| IDE 지원             | 기본적 코드 완성 및 디버깅                       | 강력한 타입 기반 자동 완성(IntelliSense), 정적 분석, 리팩터링 지원 |
| 학습 곡선            | 낮음, 빠른 학습 가능                             | 상대적으로 높음(타입 시스템 이해 필요), 대규모 프로젝트에서 유리   |
| 사용 용도            | 간단한 스크립트, 프로토타입, 작은 웹 프로젝트    | 대규모 애플리케이션, 협업 프로젝트, 리팩터링·유지보수 중점         |
| 주요 프레임워크/도구 | React, Vue, Angular, Node.js 등                  | React, Angular, Vue(특히 Vue 3), NestJS, Deno 등                   |
| 코드 안전성          | 런타임 오류가 발생할 가능성 높음                 | 컴파일 단계에서 오류 방지, 안정적 코드 보장                        |

### 웹 기반 디자인 툴에서의 폰트 설정

**프론트엔드에서 폰트를 동적으로 로드 및 적용하고, 텍스트를 다시 그려주는 복합적인 로직**으로 구성되어 있음<br>

텍스트 레이어(Text Layer) 관리

에디터 안에서 “텍스트 오브젝트”를 하나의 레이어 혹은 컴포넌트로 다뤄.

사용자가 입력한 문자열, 위치(x/y 좌표), 크기(font-size), 색상, 정렬 등 스타일 정보와 함께 “현재 어떤 폰트를 쓰는지(font-family)”라는 데이터도 내부 상태(state)에 저장해 둠.

폰트 로딩(Font Loading)

사용자가 새로운 글자체를 선택하면, 해당 폰트 파일(woff2, woff 등)을 비동기로 불러와야 함.

폰트 파일이 로드되면, “이제 이 폰트를 쓸 수 있다”라는 신호를 받게 되고, 에디터 안의 텍스트 레이어들을 새 폰트로 다시 렌더링(re-render)함.

캔버스/DOM 위에 텍스트 렌더링

미리캔버스나 Canva 내부적으로는 크게 두 가지 방식 중 하나를 쓰곤 해:

HTML/CSS 레이어:

텍스트를 <div contenteditable> 혹은 <span> 등의 HTML 요소로 두고, CSS font-family: '선택된폰트', fallback; 을 적용해 화면에 실시간 표시

이 경우, 폰트 변경 후에도 브라우저가 자동으로 다시 그려주기 때문에 비교적 간단

Canvas API (또는 WebGL 라이브러리들):

<canvas> 엘리먼트를 통해 모든 그래픽 요소(도형, 이미지, 텍스트 등)를 렌더링

텍스트를 그릴 때 CanvasRenderingContext2D의 context.font = "bold 30px '선택된폰트'" 식으로 설정한 뒤, context.fillText(text, x, y)처럼 직접 그려줘야 함

이 경우에는 “폰트가 완전히 로드 완료된 시점”을 감지해서, 폰트를 로드한 뒤에 다시 캔버스에 텍스트를 그리기 위한 로직이 필요

## 홈페이지에 나와있는 추구미

1. 단순 구현보다 **동작 원리와 구조를 깊이 이해**하며 **설계 중심의 개발**을 하고 싶은 분
2. 복잡한 상태와 로직을 다루며 **성능 최적화와 구조 개선에 관심**이 있는 분
3. **웹 에디터 편집기 개발**에 대한 경험 또는 깊은 흥미가 있는 분
4. 구조적 토론과 코드 리뷰를 통해 **함께 배우고 성장하는 문화**를 선호하는 분
5. 기능 하나를 구현하더라도 **"왜 이렇게 만들어야 하는가"**를 먼저 고민하는 분

## 미리디에 맞는 내 장점

- ⭐ 왜 이렇게 만들어야 하는가? → 집요함, 성실함
  - github 블로그를 개설하는데에 파일의 어려움이 있었지만 집요하게 해결했다. 생성되어야 하는 파일과 아닌 파일들을 하나하나 비교해가면서 오류를 해결했다.
  - UMC 활동 기간 중 프로젝트를 진행하면서 ~~
  - ~~ 여러 시도 끝에 결국 해냄!!!!!
- 동작 원리와 구조에 대해 깊이 이해 →
