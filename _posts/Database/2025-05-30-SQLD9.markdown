---
layout: post
title: "[SQLD] 기출문제 풀이"
date: 2025-05-30
category: [SQLD]
---

# 기출문제

## ➡️ ESCAPE 문자

SQL의 LIKE 구문을 사용해서 데이터 내부에 "\_"이 있는 것을 검색하는 것은?

```sql
SELECT *
FROM Mytest
WHERE name LIKE '%@_%' ESCAPE '@'
```

*는 기본적으로 와일드카드로 한 글자를 의미하기 때문에 **ESCAPE 문자**를 사용해서 문자 그대로 *를 처리해주고 \_가 있는 데이터를 찾는 쿼리를 작성한다.

- `%`: 0개 이상의 임의의 문자
- `_`: 1개 임의의 문자

## ➡️ 식별자

식별자는 대표성에 따라 주식별자와 보조식별자로 분류되고 생성 여부에 따라서 내부 식별자와 외부 식별자로 분류된다. 또한 속성의 수에 따라서 단일 식별자와 복합 식별자로 분류된다.

| 식별자 분류     | 식별자         | 설명                                                                                                                                                       |
| --------------- | -------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 대표성 여부     | **주식별자**   | 엔터티 내에서 각 행을 구분할 수 있는 구분자이며, 타 엔터티와 참조관계를 연결할 수 있는 식별자 (ex. 사원번호, 고객번호)                                     |
| 대표성 여부     | **보조식별자** | 엔터티 내에서 각 행을 구분할 수 있는 구분자이나 대표성을 가지지 못해 참조관계 연결을 못함 (ex. 주민등록번호)                                               |
| 스스로 생성여부 | **내부식별자** | 엔터티 내부에서 스스로 만들어지는 식별자 (ex. 고객번호)                                                                                                    |
| 스스로 생성여부 | **외부식별자** | 타 엔터티와의 관계를 통해 타 엔터티로부터 받아오는 식별자 (ex. 주문엔터티의 고객번호)                                                                      |
| 속성의 수       | **단일식별자** | 하나의 속성으로 구성된 식별자 (ex. 고객엔터티의 고객번호)                                                                                                  |
| 속성의 수       | **복합식별자** | 둘 이상의 속성으로 구성된 식별자 (ex. 주문상세엔터티의 주문번호+상세순번)                                                                                  |
| 대체여부        | **본질식별자** | 업무에 의해 만들어지는 식별자 (ex. 고객번호)                                                                                                               |
| 대체여부        | **인조식별자** | 업무적으로 만들어지지는 않지만 원조식별자가 복잡한 구성을 가지고 있기 때문에 인위적으로 만든 식별자 (ex. 주문엔터티의 주문번호+주문번호+주문번호+상세순번) |

## ➡️ SQL문

### 1

```sql
SELECT COUNT(COL1) AS RESULT
FROM TAB1
WHERE COL2 >= 30 GROUP BY COL1;
```

| COL1 | COL2 |
| ---- | ---- |
| A    | 10   |
| B    | NULL |
| B    | 20   |
| NULL | 30   |
| NULL | 40   |
| C    | 20   |

> 💡NULL이 count가 되는가? **NO!!!**

| RESULT |
| ------ |
| 0      |

### 2

다음 출력 결과를 얻기 위한 SQL 문장으로 가장 적절한 것은?

<\EMP> <br>

| EMPNO | ENAME  | MGR  | DEPTNO |
| ----- | ------ | ---- | ------ |
| 7369  | SMITH  | 7566 | 20     |
| 7499  | ALLEN  | 7654 | 30     |
| 7521  | WARD   | 7566 | 30     |
| 7566  | JONES  | 7654 | 20     |
| 7654  | MARTIN |      | 30     |

<\결과> <br>

| EMPNO | ENAME  | MANAGER_NAME |
| ----- | ------ | ------------ |
| 7369  | SMITH  | JONES        |
| 7499  | ALLEN  | MARTIN       |
| 7521  | WARD   | JONES        |
| 7566  | JONES  | MARTIN       |
| 7654  | MARTIN |              |

```sql
SELECT E1.EMPNO, E1.ENAME, E2.ENAME AS MANAGER_NAME
FROM EMP E1, EMP E2
WHERE E1.MGR = E2.EMPNO(+) ORDER BY E1.EMPNO;
```

SELECT절을 보면 E2.ENAME이 매니저이름이다. 따라서 E1의 MGR(매니저번호)을 갖는 E2에서의 EMPNO가 E1 사 원의 매니저라고 볼 수 있다. 또한, 매니저가 없는 MARTIN도 출력을 하기 위해서는 **LEFT OUTER JOIN**이 필요하므 로 오라클 표준으로 E1의 반대쪽 컬럼에 (+) 기호를 붙여주면 된다.

## ➡️ 분산 데이터베이스

데이터베이스를 하나의 서버에만 저장하지 않고, 여러 서버(노드)에 나눠서 저장하는 데이터베이스 시스템<br>

- **장점**
  - 지역 자치성, 점증적 시스템 용량 확장
  - 신뢰성과 가용성
  - 각 지역 사용자의 요구 수용 증대
  - 빠른 응답속도와 통신비용 절감
- **단점**
  - 처리비용의 증대
  - 설계, 관리의 복잡성과 비용
  - 오류의 잠재성 증대
  - 데이터의 무결성에 대한 위협

## ➡️ ANSI-SPARC 정의한 3단계 구조

1. **외부 스키마**: 사용자 관점
2. **개념 스키마**: 통합 관점
3. **내부 스키마**: 물리적 관점

## ➡️ UNION

UNION은 **중복된 행을 제거**하고 **정렬**한다.

## ➡️ UNION ALL

UNION ALL은 두 SELECT 결과를 합치되, **중복 제거를 하지 않**고 **정렬도 하지 않**는다.

## ➡️ 제약조건

| 제약조건               | 설명                                                             |
| ---------------------- | ---------------------------------------------------------------- |
| **기본키** PRIMARY KEY | 행을 유일하게 식별(중복 X, NULL X, 한 테이블에 하나만 설정 가능) |
| **외래키** FOREIGN KEY | 다른 테이블의 기본키 참조                                        |
| **고유키** UNIQUE KEY  | 중복값 허용 안함(NULL 허용)                                      |
| **NOT NULL**           | NULL 허용 안함                                                   |
| **CHECK**              | 특정 조건 만족해야 함                                            |
| **DEFAULT**            | 기본값 자동 입력                                                 |

## JOIN

### HASH JOIN

두 테이블을 조인할 때, 작은 테이블에 HASH TABLE을 만들어서 다른 테이블의 데이터를 빠르게 매칭시키는 조인 방식<br>
**동등 조인에서만 가능**하며 대용량 처리에 유리하다.

### NESTED LOOP JOIN

한 쪽 행마다 다른 쪽 전체 탐색 (소규모에 적합)

### MERGE JOIN

둘 다 정렬된 상태에서 합치기 (정렬된 데이터에 유리)

## DML 수행 후 원상 복구

데이터의 입력/삭제/수정 등의 DML 수행 후 원상 복구를 위한 명령어를 쓰시오.<br>
➡️ ROLLBACK
